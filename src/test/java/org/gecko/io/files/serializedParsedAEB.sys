defines{PB1_DECEL:int:=0sd32_5PB2_DECEL:int:=0sd32_10FB_DECEL:int:=0sd32_15C1:int:=0sd32_1headawayOffset:int:=0sd32_3reactTime:int:=0sd32_2}

    {=
     const int M_DEFAULT = 0, M_FCW = 1, M_PARTIAL_BREAKING_1 = 2,
              M_PARTIAL_BREAKING_2 = 3, M_FULL_BREAKING = 4;
    int abs(int x) { return x < 0 ? -x : x; }
    int min(int x, int y) { return x < y ? x : y; }
    int max(int x, int y) { return x > y ? x : y; }
    int clamp(int l, int x, int u) { return min(max(x, l), u); }
=}

contract AEBTop {
    input mioDistance: int
    input mioVelocity: int
    input egoVelocity: int
    output collision: bool
    output egoCarStop: bool
    output FCWactivate: int
    output AEBstatus: int
    output deceleration: int

    contract Element_87 := 0sd32_0<=mioDistance&0sd32_0<=egoVelocity&0sd32_0<=mioDistance&mioDistance<=0sd32_1024&-0sd32_1024<=mioVelocity&mioVelocity<=0sd32_1024 ==> (AEBstatus>0sd32_0)=(deceleration>0sd32_0)&(FCWactivate=0sd32_1)|(FCWactivate=0sd32_0)&egoCarStop=(egoVelocity<=C1)

    s1 -> s1 :: Element_87
}

contract stc {
    input egoVelocity: int
    output FCWStoppingTime: int
    output PB1StoppingTime: int
    output PB2StoppingTime: int
    output FBStoppingTime: int

    contract Element_61 := 0sd32_0<=PB1_DECEL&PB1_DECEL<=PB2_DECEL&PB2_DECEL<=FB_DECEL&0sd32_0<=egoVelocity ==> reactTime<=FCWStoppingTime&0sd32_0<=FBStoppingTime&FBStoppingTime<=PB1StoppingTime&PB1StoppingTime<=PB2StoppingTime

    s1 -> s1 :: Element_61
}

contract logic {
    input TTC: int
    input FCWtime: int
    input PB1time: int
    input PB2time: int
    input FBtime: int
    input stop: bool
    output FCWactivate: int
    output decel: int
    output AEBstatus: int
    state mode: int

    contract Element_22 := !(abs(TTC)<FCWtime&TTC>=0sd32_0) ==> AEBstatus=0sd32_0&decel=0sd32_0&FCWactivate=0sd32_0
    contract Element_26 := abs(TTC)<FCWtime&TTC>=0sd32_0 ==> AEBstatus=0sd32_0&decel=0sd32_0&FCWactivate=0sd32_1
    contract Element_33 := abs(TTC)<PB1time&TTC>=0sd32_0 ==> AEBstatus>0sd32_0&decel>0sd32_0&FCWactivate=0sd32_1
    contract Element_36 := !(abs(TTC)<PB1time&TTC>=0sd32_0) ==> AEBstatus=0sd32_0&decel=0sd32_0&FCWactivate=0sd32_1
    contract Element_29 := abs(TTC)>=(0sd32_2*FCWtime) ==> AEBstatus=0sd32_0&decel=0sd32_0&FCWactivate=0sd32_0
    contract Element_39 := !stop&TTC>=0sd32_0 ==> AEBstatus>0sd32_0&decel>0sd32_0&FCWactivate=0sd32_1
    contract Element_42 := stop&TTC<0sd32_0 ==> AEBstatus=0sd32_0&decel=0sd32_0&FCWactivate=0sd32_1

    WARN -> BREAK :: Element_33
    WARN -> WARN :: Element_36
    sTANDBY -> sTANDBY :: Element_22
    BREAK -> BREAK :: Element_39
    sTANDBY -> WARN :: Element_26
    BREAK -> sTANDBY :: Element_42
    WARN -> sTANDBY :: Element_29
}

contract ttc {
    input mioDistance: int
    input mioVelocity: int
    output TTC: int
    output collision: bool

    contract Element_51 := 0sd32_0<=mioDistance&mioDistance<=0sd32_1024&-0sd32_1024<=mioVelocity&mioVelocity<=0sd32_1024 ==> (collision=((mioDistance-headawayOffset)<0sd32_2))

    s1 -> s1 :: Element_51
}

contract gt {
    input a: int
    output v: bool

    contract Element_68 := TRUE ==> v=(a<=C1)

    s1 -> s1 :: Element_68
}

reactor AEBTop {
    input mioDistance: int
    input mioVelocity: int
    input egoVelocity: int
    output collision: bool
    output egoCarStop: bool
    output FCWactivate: int
    output AEBstatus: int
    output deceleration: int

    state stc: stc
    state logic: logic
    state ttc: ttc
    state gt: gt

    contract AEBTop

    logic.FCWactivate -> self.FCWactivate
    logic.decel -> self.deceleration
    logic.AEBstatus -> self.AEBstatus
    self.mioDistance -> ttc.mioDistance
    self.mioVelocity -> ttc.mioVelocity
    self.egoVelocity -> stc.egoVelocity
    self.egoVelocity -> gt.a
    gt.v -> self.egoCarStop
    gt.v -> logic.stop
    ttc.TTC -> logic.TTC
    ttc.collision -> self.collision
    stc.FCWStoppingTime -> logic.FCWtime
    stc.PB1StoppingTime -> logic.PB1time
    stc.PB2StoppingTime -> logic.PB2time
    stc.FBStoppingTime -> logic.FBtime

}

reactor stc {
    input egoVelocity: int
    output FCWStoppingTime: int
    output PB1StoppingTime: int
    output PB2StoppingTime: int
    output FBStoppingTime: int

    contract stc

    {=
      FBStoppingTime = egoVelocity / FB_DECEL;
      PB1StoppingTime = egoVelocity / PB1_DECEL;
      PB1StoppingTime = egoVelocity / PB2_DECEL;
      FCWStoppingTime = FBStoppingTime + reactTime;
    =}
}

reactor logic {
    input TTC: int
    input FCWtime: int
    input PB1time: int
    input PB2time: int
    input FBtime: int
    input stop: bool
    output FCWactivate: int
    output decel: int
    output AEBstatus: int
    state mode: int

    contract logic

    {=
        if ( mode == M_DEFAULT &&
                (abs(TTC) < FCWtime && TTC >= 0))
                 mode = M_FCW;
        else if(mode == M_FCW) {
                     if (abs(TTC) < PB1time && TTC >= 0) {
                       mode = M_PARTIAL_BREAKING_1;
                     } else if (abs(TTC) >= (2 * FCWtime)) {
                       mode = M_DEFAULT;
                     }
                     }
        else if(mode == M_PARTIAL_BREAKING_1) {
                     if (abs(TTC) < PB2time && TTC >= 0) {
                       mode = M_PARTIAL_BREAKING_2;
                     } else if (stop) {
                       mode = M_DEFAULT;
                     }
                     }
                   else if(mode == M_PARTIAL_BREAKING_2){
                     if (abs(TTC) < FBtime && TTC >= 0) {
                       mode = M_FULL_BREAKING;
                     } else if (stop) {
                       mode = M_DEFAULT;
                     }
                     }
         if(mode == M_FULL_BREAKING && stop) { mode = M_DEFAULT; }


         switch (mode) {
           case 0://M_DEFAULT:
             AEBstatus = 0;
             FCWactivate = 0;
             decel = 0;
             break;
           case 1://M_FCW:
             AEBstatus = 0;
             FCWactivate = 1;
             decel = 0;
             break;
           case 2://M_PARTIAL_BREAKING_1:
             AEBstatus = 1;
             FCWactivate = 1;
             decel = PB1_DECEL;
             break;
           case 3://M_PARTIAL_BREAKING_2:
             AEBstatus = 2;
             FCWactivate = 1;
             decel = PB2_DECEL;
             break;
           case 4://M_FULL_BREAKING:
             AEBstatus = 3;
             FCWactivate = 1;
             decel = FB_DECEL;
             break;
           default:
             assert(false);
           }
       =}
}

reactor ttc {
    input mioDistance: int
    input mioVelocity: int
    output TTC: int
    output collision: bool

    contract ttc

    {=
      int headaway = mioDistance - headawayOffset;
      int abs = mioVelocity < 0 ? -mioVelocity : mioVelocity;
      int clamped = clamp(10, abs, 150);
      TTC = 128 * headaway / clamped;
      TTC = TTC * (mioVelocity < 0 ? -1 : 1);
      collision = headaway < 2;
    =}
}

reactor gt {
    input a: int
    output v: bool

    contract gt

    {= v = a <= C1; =}
}
